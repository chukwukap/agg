/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedInitConfigInstruction,
  type ParsedPauseInstruction,
  type ParsedRouteInstruction,
  type ParsedSetConfigInstruction,
  type ParsedUnpauseInstruction,
} from '../instructions';

export const AGGREGATOR_PROGRAM_ADDRESS =
  '7XEqP1W4vwMtPfkkgs97RnQSeksJHT1jSFuJvg3zm2Hs' as Address<'7XEqP1W4vwMtPfkkgs97RnQSeksJHT1jSFuJvg3zm2Hs'>;

export enum AggregatorAccount {
  Config,
}

export function identifyAggregatorAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): AggregatorAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 12, 170, 224, 30, 250, 204, 130])
      ),
      0
    )
  ) {
    return AggregatorAccount.Config;
  }
  throw new Error(
    'The provided account could not be identified as a aggregator account.'
  );
}

export enum AggregatorInstruction {
  InitConfig,
  Pause,
  Route,
  SetConfig,
  Unpause,
}

export function identifyAggregatorInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): AggregatorInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([23, 235, 115, 232, 168, 96, 1, 231])
      ),
      0
    )
  ) {
    return AggregatorInstruction.InitConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([211, 22, 221, 251, 74, 121, 193, 47])
      ),
      0
    )
  ) {
    return AggregatorInstruction.Pause;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([229, 23, 203, 151, 122, 227, 173, 42])
      ),
      0
    )
  ) {
    return AggregatorInstruction.Route;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([108, 158, 154, 175, 212, 98, 52, 66])
      ),
      0
    )
  ) {
    return AggregatorInstruction.SetConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([169, 144, 4, 38, 10, 141, 188, 255])
      ),
      0
    )
  ) {
    return AggregatorInstruction.Unpause;
  }
  throw new Error(
    'The provided instruction could not be identified as a aggregator instruction.'
  );
}

export type ParsedAggregatorInstruction<
  TProgram extends string = '7XEqP1W4vwMtPfkkgs97RnQSeksJHT1jSFuJvg3zm2Hs',
> =
  | ({
      instructionType: AggregatorInstruction.InitConfig;
    } & ParsedInitConfigInstruction<TProgram>)
  | ({
      instructionType: AggregatorInstruction.Pause;
    } & ParsedPauseInstruction<TProgram>)
  | ({
      instructionType: AggregatorInstruction.Route;
    } & ParsedRouteInstruction<TProgram>)
  | ({
      instructionType: AggregatorInstruction.SetConfig;
    } & ParsedSetConfigInstruction<TProgram>)
  | ({
      instructionType: AggregatorInstruction.Unpause;
    } & ParsedUnpauseInstruction<TProgram>);
